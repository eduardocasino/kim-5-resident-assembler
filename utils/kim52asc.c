/*
 * kim52asc - A command line utility for creating plain text files from the
 *            TAP files generated by the KIM-5 Resident Assembler
 * 
 *   https://github.com/eduardocasino/kim-5-resident-assembler
 *
 * Copyright 2024 Eduardo Casino
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the “Software”),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and topermit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include <stdio.h>
#include <stdlib.h>
#include <libgen.h>
#include <unistd.h>
#include <getopt.h>
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>

#define BUF_SIZE 0x10000
#define LINE_SIZE 256

#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#define LE16(X) (uint16_t)( (( X << 8) & 0xFF00) | ((X >> 8) & 0xFF) )
#define BE16(X) (X)
#else
#define LE16(X) (X)
#define BE16(X) (uint16_t)( (( X << 8) & 0xFF00) | ((X >> 8) & 0xFF) )
#endif

typedef struct {
    struct {
        bool keep;
        bool id;
    } flags;
    char *ifilename;
    char *ofilename;
    uint8_t id;
} options_t;

int usage( char *myname )
{
    fprintf( stderr, "\nUsage: %s [-k] [-i <num>] <input_file> <output_file>\n\n", myname );

    fputs( "Arguments:\n", stderr );
    fputs( "    input_file     TAP format input file\n", stderr );
    fputs( "    output_file    Plain text output file\n\n", stderr );

    fputs( "Options:\n", stderr );
    fputs( "    -h | --help    Show this help message and exit\n", stderr );
    fputs( "    -k             Keeps line numbering in the output file\n", stderr );
    fputs( "    -i | --id      Tape index. Issues warning if don't match\n", stderr );

    return -1;
}

int duplicate( char *myname, char opt )
{
    fprintf( stderr, "Duplicate option: -%c\n", opt );
    return usage( myname );
}

int invalid( char *myname, const char *optname, char *optarg )
{
    fprintf( stderr, "Invalid %s: %s\n", optname, optarg );
    return usage( myname );    
}

int get_options( int argc, char **argv, options_t *options )
{
    int opt, opt_index = 0;
    char *myname = basename( argv[0] );
    int retcode = -1;

    memset( options, 0, sizeof( options_t ) );

    static const struct option long_opts[] = {
        {"keep",           no_argument,       0, 'k' },
        {"id",             required_argument, 0, 'i' },
        {"help",           no_argument,       0, 'h' },
        {0,                0 ,                0,  0  }
    };
    
    while (( opt = getopt_long( argc, argv, "i:kh", long_opts, &opt_index)) != -1 )
    {
        switch( opt )
        {
            uint64_t number;
            char *endc;
            
            case 'i':
                if ( options->flags.id++ )
                {
                    return duplicate( myname, opt );
                }
                
                number = strtoul( optarg, &endc, 0 );

                if ( (number > 0xFE) || (number < 1) || *endc )
                {
                    return invalid( myname, "tape id", optarg );
                }

                options->id = (uint8_t) number;
                break;

            case 'k':
                if ( options->flags.keep++ )
                {
                    return duplicate( myname, opt );
                }
                break;

            default:
                return usage( myname );
        }
    }

    if ( argc - optind < 2 )
    {
        fputs( "Input and output files are mandatory\n", stderr );
        return usage( myname );
    }

    options->ifilename = argv[optind++];
    options->ofilename = argv[optind++];

    return 0;
}

void output_err( char *filename )
{
    fprintf( stderr, "Error writing to the output file %s: %s\n", filename, strerror( errno ) );
}

uint16_t bcddec( uint16_t number )
{
    const int weight[] = { 1000, 100, 10, 1 };
    uint16_t decoded = 0;
    uint8_t nibble;

    for ( int n = 0; n < 4; ++n )
    {
        nibble = ( number >> (4 * ( 3 - n )) ) & 0x0F;

        if ( nibble > 9 )
        {
            return 0xFFFF;
        }
        decoded += nibble * weight[n];
    }

    return decoded;
}

int main( int argc, char **argv )
{
    static char input_buf[ BUF_SIZE ];
    static char line_buf[ LINE_SIZE + 2 ];
    options_t options;
    FILE *input, *output = NULL;
    uint8_t input_byte;
    size_t nread, index = 0;
    int status = 0;

    if ( get_options( argc, argv, &options ) )
    {
        return -1;
    }
    
    if ( NULL == ( input = fopen( options.ifilename, "rb" ) ) )
    {
        perror( "Can't open input file" );
        return -1;
    }

    if ( 0 == ( nread = fread( input_buf, 1, sizeof( input_buf ), input ) ) )
    {
        fprintf( stderr, "Error reading from the input file %s: %s\n", options.ifilename, strerror( errno ) );
        fclose( input );        
        return -1;
    }

    if ( 0x2A != input_buf[index] )
    {
        fputs( "Not a valid TAP file\n", stderr );
        fclose( input );        
        return -1;
    }
    ++index;

    // Header byte + id byte + start word + end word + 1st line word + 1 char
    // + EOL byte + EOF word + End of tape byte + checksum word + two end bytes 
    if ( nread < 17 )
    {
        fputs( "Corrupted or invalid input file\n", stderr );
        fclose( input );        
        return -1;
    }

    if ( options.flags.id && input_buf[index] != options.id )
    {
        fprintf( stderr, "Warning: Tape IDs do not match: %2.2X\n", input_buf[index] );
    }

    ++index;

    printf( "Saved from 0x%4.4X-0x%4.4X\n",
            LE16(*(uint16_t *)&input_buf[index]), LE16(*(uint16_t *)&input_buf[index+2]) );

    index += 4;

    if ( NULL == ( output = fopen( options.ofilename, "w" ) ) )
    {
        perror( "Can't open output file" );
        fclose( input );
        return -1;
    }

    while ( nread - index > 2 )
    {
        char *s;
        
        if ( input_buf[index] == 0x1F )
        {
            // End of text file
            ++status;
            break;
        }

        if ( options.flags.keep )
        {
            uint16_t linenum = bcddec( BE16( *(uint16_t*)&input_buf[index] ) );

            if ( linenum != 0xFFFF )
            {
                if ( fprintf( output, "%4u ", linenum ) < 0 )
                {
                    output_err( options.ofilename );
                    --status;
                    break;
                }
            }
            else
            {
                fprintf( stderr, "Invalid line number: %2.2X%2.2X\n", input_buf[index], input_buf[index+1] );
                --status;
                break;
            }
        }
        index += 2;

        if ( NULL == ( s = memchr( &input_buf[index], '\r', nread-index ) ) )
        {
            fputs( "Bad input format: expecting '\\r'\n", stderr );
            --status;
            break;
        }
        *s = '\0';

        if ( EOF == fprintf( output, "%s\n", &input_buf[index+1] ) )
        {
            output_err( options.ofilename );
            --status;
            break;
        }

        index += s - &input_buf[index] + 1;
    }
        
    if ( fclose( output ) )
    {
        output_err( options.ofilename );
        --status;
    }

    if ( status == 0 )
    {
        fputs( "Truncated or invalid input file\n", stderr );
        --status;
    }

    return status;
}